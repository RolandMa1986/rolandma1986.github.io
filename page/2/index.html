<!DOCTYPE html>
<html lang="zh-cn">
    <head>
	<meta name="generator" content="Hugo 0.74.3" />
		
		
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<meta name="description" content="奔四程序员，不会写博客～～">

		<title>Roland&#39;s Blog</title>

		
		<link rel="stylesheet" href="/css/style.css">
		<link rel="stylesheet" href="/css/fonts.css">
		
		<link rel="icon" href="favicon.ico" />
		<link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
		<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

		
		<link href="/index.xml" rel="alternate" type="application/rss+xml" title="Roland&#39;s Blog" />
	</head>

    <body>
        		<nav class="nav">
			<div class="nav-container">
				<a href="/">
					
						<h1 class="nav-title">Roland&#39;s Blog</h1>
					
				</a>
				<ul>
    
    
</ul>
			</div>
		</nav>

        

<main>
	


	<div class="catalogue">
		
			<a href="/post/kubernetes-multi-tenancy-kiosk/" class="catalogue-item">
    <div>
        <time datetime="2020-12-30 20:46:17 &#43;0800 &#43;0800" class="catalogue-time">December 30, 2020</time>
        <h2 class="catalogue-title">Kiosk 多租户扩展-基本概念</h2>
        <div class="catalogue-line"></div>

        <p>
            Kubernetes 多租户扩展  使用 Accounts 与 Account User 在共享的 Kubernetes 集群中区分租户 租户自助 Namespace 空间配置 Account Limits 账户配额保障服务质量与公平性 Namespace Templates 命名空间模板保证租户隔离与自助初始化 Namespace。 *多集群租户管理以共享集群池  Why kiosk Kubernetes 被设计为一个单租户平台，因此在单集群上实现多租户功能变得十分困难。然而，共享一个集群有很多优势，例如，资源利用率高，管理配置成本低，也可使租户更容易共享集群内部资源。
当然，创建多租户 Kubernetes 集群的方法有很多，许多 Kubernetes 发行版也提出了他们自己的租户逻辑，然而却没有一个种轻量级的，可热拔插，并可定制化的解决方案。使管理员可以在任何标准的 Kubernetes 集群之上增加多租户能力。
kiosk 愿景  100% 开源：使用 CNCF 兼容的 Apache 2.0 license 即插即用：可轻而易举地在任何已有集群中安装，适用于多种不同的场景 快速：着重于租户的自动化与自助服务 安全：为不同级别的租户隔离提供默认配置 可扩展：providing building blocks for higher-level Kubernetes platforms  架构 kiosk 的核心理念是使用 Kubernetes Namespace 作为隔离的工作空间，租户的应用可以运行在彼此隔离的空间中。为了降低管理成本，集群管理员应该配置 kiosk，然后它将成为一个租户可以在 Kubernetes 中自助配置 Namespace 的系统。
        </p>
    </div>
</a>

		
			<a href="/post/kubernetes-multi-tenancy-hnc/" class="catalogue-item">
    <div>
        <time datetime="2020-12-28 20:34:37 &#43;0800 &#43;0800" class="catalogue-time">December 28, 2020</time>
        <h2 class="catalogue-title">Kubernetes 层级命名空间 HNC - 3 Why</h2>
        <div class="catalogue-line"></div>

        <p>
            为什么使用 namespaces? 在深入讨论层级空间前，我们有必要先考虑一下为何 Kubernetes 使用了命名空间的概念。
首先，也是最重要的，命名空间提供了一种组织 Kubernetes 对象的方式，可以防止同名问题，即集群中的任何 Kind 的实例对象命名必须唯一的问题。对于不同的 Kind 对象命名是可以相同的，但是同一种对象在同一命名空间下是不允许重现重名。对于 Kubernetes 用户，这也有利于用户使用简短的命名，如 frontend 或 database, 而不必担心在集群中产生命名冲突。
其次，重要也很巧妙的设计是，在控制面中命名空间是安全隔离的主要单元和身份标示。他们具有排他性，也就是说，命名空间中的对象属于且仅属于一个命名空间。如上所述，它将对象进行分组。这些分组的独立性使他们可以自然的关联一组相关的对象。 例如，命名空间被作为各种策略的默认目标，如 RoleBinding, Network Policies, 这也适用于 Kubernetes 扩展，如 Istio Polices。
当然，在命名空间内应用策略也是可行的，但是 Kubernetes 对他的支持有限，且容易引起错误，同时在 Kuberenets 生态系统中容易使用户产生困惑。例如，RBAC 策略可以应用于目标对象的名称，但是这些策略很难以维护。
再如，命名空间中的 Pod 可以使用同空间下的任何 Service Account 运行， 甚至是远超过 Pod 运行所需的特权。管理员在不借助 Validting Admission Contoller 或 OPA Gatekeeper 等高级技术情况下，通常无法直接限制。结果是，作用于 Service Account 的各种策略是弱策略，除非这些 Service Account 来自不同的命名空间。
        </p>
    </div>
</a>

		
			<a href="/post/how-to-get-source-code-of-package/" class="catalogue-item">
    <div>
        <time datetime="2020-12-14 15:03:27 &#43;0000 UTC" class="catalogue-time">December 14, 2020</time>
        <h2 class="catalogue-title">使用 apt 命令获取 Ubuntu 安装包源码</h2>
        <div class="catalogue-line"></div>

        <p>
            <p>由于最近需要研究一个关于 Ubuntu 上 systemd 的问题，因此需要下载 systemd 的源代码。 一般源码下载可以在官网或者Github中下载，如 systemd。但是由于 linux 各个分发版本可能会给它们打上自己的补丁，因此我们需要从 Ubuntu 下载其源码包。在 Debian 或 Ubuntu 的系统中源码是文件版的软件发行包，因此我们可以使用 apt-get 或者 apt 命令下载其源码 (DEB 文件包)。</p>
        </p>
    </div>
</a>

		
			<a href="/post/kubernetes-no-podsandbox-found/" class="catalogue-item">
    <div>
        <time datetime="2020-12-08 03:38:37 &#43;0000 UTC" class="catalogue-time">December 8, 2020</time>
        <h2 class="catalogue-title">Kubernetes - &#39;No Podsandbox Found with Id&#39; 导致 Kubelet 启动失败分析过程总结</h2>
        <div class="catalogue-line"></div>

        <p>
            <p>某线上客户反应 Kubernetes 集群中一节点显示为 &ldquo;NotReady&rdquo; 状态，重启 Kubelet 后任然无法恢复。由于无法连接环境，只能拿到少量相关日志信息，因此尝试本地重现。</p>
        </p>
    </div>
</a>

		
			<a href="/post/kubernetes-rbac-certificates/" class="catalogue-item">
    <div>
        <time datetime="2020-12-04 00:37:34 &#43;0000 UTC" class="catalogue-time">December 4, 2020</time>
        <h2 class="catalogue-title">Kubernetes RBAC - 证书认证</h2>
        <div class="catalogue-line"></div>

        <p>
            X509 客户证书 一般 Kubernetes 集群都会启用基于客户证书的用户认证模式。 API Server 通过 --client-ca-file=SOMEFILE 选项配置 CA 证书用于客户证书认证。如果提供的证书被验证通过，则 subject 中的公共名称（Common Name）就被作为请求的用户名。 通常可以使用两种方式签发：
 通过 CertificateSigningRequest 资源类型允许客户申请签名 X.509 证书 使用外部证书服务颁发证书，如 openssl  通过 CSR API 签发证书步骤：  生成用户私钥：  openssl genrsa -out user2.key 2048 使用私钥生成证书签名请求 CSR:  openssl req -new -key user2.key -out user2.csr -subj &#34;/CN=user2/O=group1/O=group2&#34;  如果遇到错误信息 Can't load /home/ubuntu/.
        </p>
    </div>
</a>

		
	</div>

	<div class="pagination">
		
			<a href="/" class="left arrow">&#8592;</a>
		
		
			<a href="/page/3/" class="right arrow">&#8594;</a>
		

		<span>2</span>
	</div>
</main>


        		<footer>
			
			<span>
			&copy; <time datetime="2021-12-08 02:04:07.211160232 &#43;0000 UTC m=&#43;0.325175618">2021</time> . Made with <a href='https://gohugo.io'>Hugo</a> using the <a href='https://github.com/EmielH/tale-hugo/'>Tale</a> theme.
			</span>
		</footer>

    </body>
</html>
